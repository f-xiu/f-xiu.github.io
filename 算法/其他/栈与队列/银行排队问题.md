【问题描述】

一个系统模仿另一个系统行为的技术称为**模拟**，如飞行模拟器。模拟可以用来进行方案论证、人员培训和改进服务。计算机技术常用于模拟系统中。

**生产者****-****消费者**（Server-Custom）是常见的应用模式，见于银行、食堂、打印机、医院、超等提供服务和使用服务的应用中。这类应用的主要问题是消费者如果等待（排队）时间过长，会引发用户抱怨，影响服务质量；如果提供服务者（服务窗口）过多，将提高运管商成本。（经济学中排队论）

假设某银行网点有五个服务窗口，分别为三个对私、一个对公和一个外币窗口。银行服务的原则是先来先服务。通常对私业务人很多，其它窗口人则较少，可临时改为对私服务。假设当对私窗口等待服务的客户（按实际服务窗口）平均排队人数超过（大于或等于）7人时，等待客户将可能有抱怨，影响服务质量，此时银行可临时将其它窗口中一个或两个改为对私服务，当客户少于7人时，将立即恢复原有业务。设计一个程序用来模拟银行服务。

说明：

\1. 增加服务窗口将会增加成本或影响其它业务，因此，以成本增加或影响最小为原则来增加服务窗口，即如果增加一个窗口就能使得按窗口平均等待服务人数小于7人，则只增加一个窗口。一旦按窗口平均等待服务人数小于7人，就减少一个所增加的窗口。

\2. 为了简化问题，假设新到客户是在每个服务周期开始时到达。

\3. 当等待服务人数发生变化时（新客户到达或有客户已接受服务），则及时计算按实际服务窗口平均等待服务人数，并按相应策略调整服务窗口数（增加或减少额外的服务窗口，但对私窗口不能减少）。**注意：只在获取新客户（不管到达新客户数是否为0）时或已有客户去接受服务时，才按策略调整服务窗口数。进一步讲，增加服务窗口只在有客户到达的周期内进行（也就是说增加窗口是基于客户的感受，银行对增加窗口是不情愿的，因为要增加成本，一旦不再有新客户来，银行是不会再增加服务窗口的）；一旦有客户去接受服务（即等待客户减少），银行将根据策略及时减少服务窗口，因此，在每个周期内，有客户去接受服务后要马上判断是否减少服务窗口（因为能减少成本，银行是积极的）**



本问题中假设对公和对外币服务窗口在改为对私服务时及服务期间没有相应因公或外币服务新客户到达（即正好空闲），同时要求以增加成本或影响最小为前提，来尽最大可能减少对私服务客户等待时间。

【输入形式】

首先输入一个整数表示时间周期数，然后再依次输入每个时间周期中因私业务的客户数。注：一个时间周期指的是银行处理一笔业务的平均处理时间，可以是一分钟、三分钟或其它。例如：

6

2 5 13 11 15  9 



说明：表明在6个时间周期内，第1个周期来了2个（序号分别为1,2），第2个来了5人（序号分别为3,4,5,6,7），以此类推。

【输出形式】

每个客户等待服务的时间周期数。输出形式如下：

用户序号 : 等待周期数

说明：客户序号与等待周期数之间用符号:分隔，冒号（:）**两边各有一个空格**，等待周期数后直接为回车。

**读题：有客户接受服务后要马上判断是否减少服务窗口。**

**如何减少：如果按窗口平均等待服务人数小于7，就立马减少窗口（没有考虑到减少窗口后，是否会导致平均等待服务人数可能会大于7.）**

**而且：如果没有新客户来就不会增加窗口。**

```
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;

typedef struct Node{
    int number;
    int start;
    Node(){}
    Node(int _num,int _start){
        number=_num;
        start=_start;
    }
}Node;
int main(void){
    
    queue<Node>Q;
    int time_T=0;

    cin>>time_T;
    int *nums=new int[time_T]; 
    for(int i=0;i<time_T;i++){
        cin>>nums[i];
    }
    int t=0;
    int count=1;
    int windows=3;
    while(Q.size()>0||t<time_T){
        if(t<time_T){
            for(int i=0;i<nums[t];i++){
                Node tm(count++,t);
                Q.push(tm);
            }
        }
        while(t<time_T&&windows<5&&((int)Q.size()/windows>=7))windows++;
        for(int i=0;i<windows&&(int)Q.size()>0;i++){
            Node tm=Q.front();
            cout<<tm.number<<" : "<<t-tm.start<<endl;
            Q.pop();
        }
        //该窗口数可以缩小，立刻减少，这里不是/（window-1）
        while(windows>3&&((int)Q.size()/windows<7))windows--;
        t++;
    }
    return 0;
}
```

